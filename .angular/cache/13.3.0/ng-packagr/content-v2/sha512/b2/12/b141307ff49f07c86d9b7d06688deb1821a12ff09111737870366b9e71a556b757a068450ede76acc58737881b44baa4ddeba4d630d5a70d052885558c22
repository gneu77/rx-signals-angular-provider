{"hash":"114fead4d7b7bdddf955050a122214db328cf718","fesm2020":{"code":"import * as i0 from '@angular/core';\nimport { NgModule } from '@angular/core';\nimport { Store } from '@rx-signals/store';\n\n// The root store is a singleton that should live as long as the whole application\r\n// In case other lifecycles are required (e.g. restricted to the lifecycle of\r\n// a certain module), corresponding child-stores should be derived from the\r\n// root store\r\nconst rootStore = new Store();\r\nclass RxSignalsStoreModule {\r\n    /**\r\n     * Use withRootStore, if you need the root store that shares the lifecycle of the whole application.\r\n     * Also lazy-loaded feature modules will receive the same root-store instance, if you use withRootStore.\r\n     * This should be the standard case.\r\n     *\r\n     * @param {function} setup - optional callback that receives the store and performs setup\r\n     * @returns {ModuleWithProviders<RxSignalsStoreModule>} the module providing the root-store\r\n     */\r\n    static withRootStore(setup) {\r\n        let doSetup = (setup ?? null) !== null;\r\n        return {\r\n            ngModule: RxSignalsStoreModule,\r\n            providers: [{ provide: Store, useFactory: () => {\r\n                        if (doSetup && setup) {\r\n                            doSetup = false;\r\n                            setup(rootStore);\r\n                        }\r\n                        return rootStore;\r\n                    } }],\r\n        };\r\n    }\r\n    /**\r\n     * Use withChildStore, if you need a child store that is derived from the root-store.\r\n     * See store.createChildStore() for further documentation on child stores.\r\n     *\r\n     * @param {function} setup - optional callback that receives the child-store and performs setup\r\n     * @returns {ModuleWithProviders<RxSignalsStoreModule>} the module providing the child-store\r\n     */\r\n    static withChildStore(setup) {\r\n        let doSetup = (setup ?? null) !== null;\r\n        const childStore = rootStore.createChildStore();\r\n        return {\r\n            ngModule: RxSignalsStoreModule,\r\n            providers: [{ provide: Store, useFactory: () => {\r\n                        if (doSetup && setup) {\r\n                            doSetup = false;\r\n                            setup(childStore);\r\n                        }\r\n                        return childStore;\r\n                    } }],\r\n        };\r\n    }\r\n}\r\nRxSignalsStoreModule.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: \"12.0.0\", version: \"13.3.0\", ngImport: i0, type: RxSignalsStoreModule, deps: [], target: i0.ɵɵFactoryTarget.NgModule });\r\nRxSignalsStoreModule.ɵmod = i0.ɵɵngDeclareNgModule({ minVersion: \"12.0.0\", version: \"13.3.0\", ngImport: i0, type: RxSignalsStoreModule });\r\nRxSignalsStoreModule.ɵinj = i0.ɵɵngDeclareInjector({ minVersion: \"12.0.0\", version: \"13.3.0\", ngImport: i0, type: RxSignalsStoreModule, providers: [{ provide: Store, useValue: rootStore }] // default to rootStore, if none of the static providers is used\r\n });\r\ni0.ɵɵngDeclareClassMetadata({ minVersion: \"12.0.0\", version: \"13.3.0\", ngImport: i0, type: RxSignalsStoreModule, decorators: [{\r\n            type: NgModule,\r\n            args: [{\r\n                    providers: [{ provide: Store, useValue: rootStore }] // default to rootStore, if none of the static providers is used\r\n                }]\r\n        }] });\n\n/*\r\n * Public API Surface of angular-provider\r\n */\n\n/**\r\n * Generated bundle index. Do not edit.\r\n */\n\nexport { RxSignalsStoreModule };\n//# sourceMappingURL=rx-signals-angular-provider.mjs.map\n","map":{"version":3,"file":"rx-signals-angular-provider.mjs","sources":["../../../../projects/rx-signals/angular-provider/src/lib/rx-signals-store.module.ts","../../../../projects/rx-signals/angular-provider/src/public-api.ts","../../../../projects/rx-signals/angular-provider/src/rx-signals-angular-provider.ts"],"sourcesContent":["import { ModuleWithProviders, NgModule } from '@angular/core';\nimport { Store } from '@rx-signals/store';\n\n// The root store is a singleton that should live as long as the whole application\n// In case other lifecycles are required (e.g. restricted to the lifecycle of\n// a certain module), corresponding child-stores should be derived from the\n// root store\nconst rootStore = new Store();\n\n@NgModule({\n  providers: [{ provide: Store, useValue: rootStore }] // default to rootStore, if none of the static providers is used\n})\nexport class RxSignalsStoreModule {\n  \n  /**\n   * Use withRootStore, if you need the root store that shares the lifecycle of the whole application.\n   * Also lazy-loaded feature modules will receive the same root-store instance, if you use withRootStore.\n   * This should be the standard case.\n   *\n   * @param {function} setup - optional callback that receives the store and performs setup\n   * @returns {ModuleWithProviders<RxSignalsStoreModule>} the module providing the root-store\n   */\n  static withRootStore(setup?: (store: Store) => void): ModuleWithProviders<RxSignalsStoreModule> {\n    let doSetup = (setup ?? null) !== null;\n    return {\n      ngModule: RxSignalsStoreModule,\n      providers: [{ provide: Store, useFactory: () => {\n        if (doSetup && setup) {\n          doSetup = false;\n          setup(rootStore);\n        }\n        return rootStore;\n      }}],\n    };\n  }\n\n  /**\n   * Use withChildStore, if you need a child store that is derived from the root-store.\n   * See store.createChildStore() for further documentation on child stores.\n   *\n   * @param {function} setup - optional callback that receives the child-store and performs setup\n   * @returns {ModuleWithProviders<RxSignalsStoreModule>} the module providing the child-store\n   */\n  static withChildStore(setup?: (store: Store) => void): ModuleWithProviders<RxSignalsStoreModule> {\n    let doSetup = (setup ?? null) !== null;\n    const childStore = rootStore.createChildStore();\n    return {\n      ngModule: RxSignalsStoreModule,\n      providers: [{ provide: Store, useFactory: () => {\n        if (doSetup && setup) {\n          doSetup = false;\n          setup(childStore);\n        }\n        return childStore;\n      }}],\n    };\n  }\n}\n","/*\n * Public API Surface of angular-provider\n */\n\nexport * from './lib/rx-signals-store.module';\n\n","/**\n * Generated bundle index. Do not edit.\n */\n\nexport * from './public-api';\n"],"names":[],"mappings":";;;;AAGA;AACA;AACA;AACA;AACA,MAAM,SAAS,GAAG,IAAI,KAAK,EAAE,CAAC;MAKjB,oBAAoB,CAAA;AAE/B;;;;;;;AAOG;IACH,OAAO,aAAa,CAAC,KAA8B,EAAA;QACjD,IAAI,OAAO,GAAG,CAAC,KAAK,IAAI,IAAI,MAAM,IAAI,CAAC;QACvC,OAAO;AACL,YAAA,QAAQ,EAAE,oBAAoB;YAC9B,SAAS,EAAE,CAAC,EAAE,OAAO,EAAE,KAAK,EAAE,UAAU,EAAE,MAAK;wBAC7C,IAAI,OAAO,IAAI,KAAK,EAAE;4BACpB,OAAO,GAAG,KAAK,CAAC;4BAChB,KAAK,CAAC,SAAS,CAAC,CAAC;AAClB,yBAAA;AACD,wBAAA,OAAO,SAAS,CAAC;AACnB,qBAAC,EAAC,CAAC;SACJ,CAAC;KACH;AAED;;;;;;AAMG;IACH,OAAO,cAAc,CAAC,KAA8B,EAAA;QAClD,IAAI,OAAO,GAAG,CAAC,KAAK,IAAI,IAAI,MAAM,IAAI,CAAC;AACvC,QAAA,MAAM,UAAU,GAAG,SAAS,CAAC,gBAAgB,EAAE,CAAC;QAChD,OAAO;AACL,YAAA,QAAQ,EAAE,oBAAoB;YAC9B,SAAS,EAAE,CAAC,EAAE,OAAO,EAAE,KAAK,EAAE,UAAU,EAAE,MAAK;wBAC7C,IAAI,OAAO,IAAI,KAAK,EAAE;4BACpB,OAAO,GAAG,KAAK,CAAC;4BAChB,KAAK,CAAC,UAAU,CAAC,CAAC;AACnB,yBAAA;AACD,wBAAA,OAAO,UAAU,CAAC;AACpB,qBAAC,EAAC,CAAC;SACJ,CAAC;KACH;;iHA5CU,oBAAoB,EAAA,IAAA,EAAA,EAAA,EAAA,MAAA,EAAA,EAAA,CAAA,eAAA,CAAA,QAAA,EAAA,CAAA,CAAA;kHAApB,oBAAoB,EAAA,CAAA,CAAA;AAApB,oBAAA,CAAA,IAAA,GAAA,EAAA,CAAA,mBAAA,CAAA,EAAA,UAAA,EAAA,QAAA,EAAA,OAAA,EAAA,QAAA,EAAA,QAAA,EAAA,EAAA,EAAA,IAAA,EAAA,oBAAoB,EAFpB,SAAA,EAAA,CAAC,EAAE,OAAO,EAAE,KAAK,EAAE,QAAQ,EAAE,SAAS,EAAE,CAAC;;2FAEzC,oBAAoB,EAAA,UAAA,EAAA,CAAA;kBAHhC,QAAQ;AAAC,YAAA,IAAA,EAAA,CAAA;AACR,oBAAA,SAAS,EAAE,CAAC,EAAE,OAAO,EAAE,KAAK,EAAE,QAAQ,EAAE,SAAS,EAAE,CAAC;AACrD,iBAAA,CAAA;;;ACXD;;AAEG;;ACFH;;AAEG;;;;"}},"fesm2015":{"code":"import * as i0 from '@angular/core';\nimport { NgModule } from '@angular/core';\nimport { Store } from '@rx-signals/store';\n\n// The root store is a singleton that should live as long as the whole application\r\n// In case other lifecycles are required (e.g. restricted to the lifecycle of\r\n// a certain module), corresponding child-stores should be derived from the\r\n// root store\r\nconst rootStore = new Store();\r\nclass RxSignalsStoreModule {\r\n    /**\r\n     * Use withRootStore, if you need the root store that shares the lifecycle of the whole application.\r\n     * Also lazy-loaded feature modules will receive the same root-store instance, if you use withRootStore.\r\n     * This should be the standard case.\r\n     *\r\n     * @param {function} setup - optional callback that receives the store and performs setup\r\n     * @returns {ModuleWithProviders<RxSignalsStoreModule>} the module providing the root-store\r\n     */\r\n    static withRootStore(setup) {\r\n        let doSetup = (setup !== null && setup !== void 0 ? setup : null) !== null;\r\n        return {\r\n            ngModule: RxSignalsStoreModule,\r\n            providers: [{ provide: Store, useFactory: () => {\r\n                        if (doSetup && setup) {\r\n                            doSetup = false;\r\n                            setup(rootStore);\r\n                        }\r\n                        return rootStore;\r\n                    } }],\r\n        };\r\n    }\r\n    /**\r\n     * Use withChildStore, if you need a child store that is derived from the root-store.\r\n     * See store.createChildStore() for further documentation on child stores.\r\n     *\r\n     * @param {function} setup - optional callback that receives the child-store and performs setup\r\n     * @returns {ModuleWithProviders<RxSignalsStoreModule>} the module providing the child-store\r\n     */\r\n    static withChildStore(setup) {\r\n        let doSetup = (setup !== null && setup !== void 0 ? setup : null) !== null;\r\n        const childStore = rootStore.createChildStore();\r\n        return {\r\n            ngModule: RxSignalsStoreModule,\r\n            providers: [{ provide: Store, useFactory: () => {\r\n                        if (doSetup && setup) {\r\n                            doSetup = false;\r\n                            setup(childStore);\r\n                        }\r\n                        return childStore;\r\n                    } }],\r\n        };\r\n    }\r\n}\r\nRxSignalsStoreModule.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: \"12.0.0\", version: \"13.3.0\", ngImport: i0, type: RxSignalsStoreModule, deps: [], target: i0.ɵɵFactoryTarget.NgModule });\r\nRxSignalsStoreModule.ɵmod = i0.ɵɵngDeclareNgModule({ minVersion: \"12.0.0\", version: \"13.3.0\", ngImport: i0, type: RxSignalsStoreModule });\r\nRxSignalsStoreModule.ɵinj = i0.ɵɵngDeclareInjector({ minVersion: \"12.0.0\", version: \"13.3.0\", ngImport: i0, type: RxSignalsStoreModule, providers: [{ provide: Store, useValue: rootStore }] // default to rootStore, if none of the static providers is used\r\n});\r\ni0.ɵɵngDeclareClassMetadata({ minVersion: \"12.0.0\", version: \"13.3.0\", ngImport: i0, type: RxSignalsStoreModule, decorators: [{\r\n            type: NgModule,\r\n            args: [{\r\n                    providers: [{ provide: Store, useValue: rootStore }] // default to rootStore, if none of the static providers is used\r\n                }]\r\n        }] });\n\n/*\r\n * Public API Surface of angular-provider\r\n */\n\n/**\r\n * Generated bundle index. Do not edit.\r\n */\n\nexport { RxSignalsStoreModule };\n//# sourceMappingURL=rx-signals-angular-provider.mjs.map\n","map":{"version":3,"file":"rx-signals-angular-provider.mjs","sources":["../../../../projects/rx-signals/angular-provider/src/lib/rx-signals-store.module.ts","../../../../projects/rx-signals/angular-provider/src/public-api.ts","../../../../projects/rx-signals/angular-provider/src/rx-signals-angular-provider.ts"],"sourcesContent":["import { ModuleWithProviders, NgModule } from '@angular/core';\nimport { Store } from '@rx-signals/store';\n\n// The root store is a singleton that should live as long as the whole application\n// In case other lifecycles are required (e.g. restricted to the lifecycle of\n// a certain module), corresponding child-stores should be derived from the\n// root store\nconst rootStore = new Store();\n\n@NgModule({\n  providers: [{ provide: Store, useValue: rootStore }] // default to rootStore, if none of the static providers is used\n})\nexport class RxSignalsStoreModule {\n  \n  /**\n   * Use withRootStore, if you need the root store that shares the lifecycle of the whole application.\n   * Also lazy-loaded feature modules will receive the same root-store instance, if you use withRootStore.\n   * This should be the standard case.\n   *\n   * @param {function} setup - optional callback that receives the store and performs setup\n   * @returns {ModuleWithProviders<RxSignalsStoreModule>} the module providing the root-store\n   */\n  static withRootStore(setup?: (store: Store) => void): ModuleWithProviders<RxSignalsStoreModule> {\n    let doSetup = (setup ?? null) !== null;\n    return {\n      ngModule: RxSignalsStoreModule,\n      providers: [{ provide: Store, useFactory: () => {\n        if (doSetup && setup) {\n          doSetup = false;\n          setup(rootStore);\n        }\n        return rootStore;\n      }}],\n    };\n  }\n\n  /**\n   * Use withChildStore, if you need a child store that is derived from the root-store.\n   * See store.createChildStore() for further documentation on child stores.\n   *\n   * @param {function} setup - optional callback that receives the child-store and performs setup\n   * @returns {ModuleWithProviders<RxSignalsStoreModule>} the module providing the child-store\n   */\n  static withChildStore(setup?: (store: Store) => void): ModuleWithProviders<RxSignalsStoreModule> {\n    let doSetup = (setup ?? null) !== null;\n    const childStore = rootStore.createChildStore();\n    return {\n      ngModule: RxSignalsStoreModule,\n      providers: [{ provide: Store, useFactory: () => {\n        if (doSetup && setup) {\n          doSetup = false;\n          setup(childStore);\n        }\n        return childStore;\n      }}],\n    };\n  }\n}\n","/*\n * Public API Surface of angular-provider\n */\n\nexport * from './lib/rx-signals-store.module';\n\n","/**\n * Generated bundle index. Do not edit.\n */\n\nexport * from './public-api';\n"],"names":[],"mappings":";;;;AAGA;AACA;AACA;AACA;AACA,MAAM,SAAS,GAAG,IAAI,KAAK,EAAE,CAAC;MAKjB,oBAAoB,CAAA;AAE/B;;;;;;;AAOG;IACH,OAAO,aAAa,CAAC,KAA8B,EAAA;AACjD,QAAA,IAAI,OAAO,GAAG,CAAC,KAAK,KAAL,IAAA,IAAA,KAAK,KAAL,KAAA,CAAA,GAAA,KAAK,GAAI,IAAI,MAAM,IAAI,CAAC;QACvC,OAAO;AACL,YAAA,QAAQ,EAAE,oBAAoB;YAC9B,SAAS,EAAE,CAAC,EAAE,OAAO,EAAE,KAAK,EAAE,UAAU,EAAE,MAAK;wBAC7C,IAAI,OAAO,IAAI,KAAK,EAAE;4BACpB,OAAO,GAAG,KAAK,CAAC;4BAChB,KAAK,CAAC,SAAS,CAAC,CAAC;AAClB,yBAAA;AACD,wBAAA,OAAO,SAAS,CAAC;AACnB,qBAAC,EAAC,CAAC;SACJ,CAAC;KACH;AAED;;;;;;AAMG;IACH,OAAO,cAAc,CAAC,KAA8B,EAAA;AAClD,QAAA,IAAI,OAAO,GAAG,CAAC,KAAK,KAAL,IAAA,IAAA,KAAK,KAAL,KAAA,CAAA,GAAA,KAAK,GAAI,IAAI,MAAM,IAAI,CAAC;AACvC,QAAA,MAAM,UAAU,GAAG,SAAS,CAAC,gBAAgB,EAAE,CAAC;QAChD,OAAO;AACL,YAAA,QAAQ,EAAE,oBAAoB;YAC9B,SAAS,EAAE,CAAC,EAAE,OAAO,EAAE,KAAK,EAAE,UAAU,EAAE,MAAK;wBAC7C,IAAI,OAAO,IAAI,KAAK,EAAE;4BACpB,OAAO,GAAG,KAAK,CAAC;4BAChB,KAAK,CAAC,UAAU,CAAC,CAAC;AACnB,yBAAA;AACD,wBAAA,OAAO,UAAU,CAAC;AACpB,qBAAC,EAAC,CAAC;SACJ,CAAC;KACH;;iHA5CU,oBAAoB,EAAA,IAAA,EAAA,EAAA,EAAA,MAAA,EAAA,EAAA,CAAA,eAAA,CAAA,QAAA,EAAA,CAAA,CAAA;kHAApB,oBAAoB,EAAA,CAAA,CAAA;AAApB,oBAAA,CAAA,IAAA,GAAA,EAAA,CAAA,mBAAA,CAAA,EAAA,UAAA,EAAA,QAAA,EAAA,OAAA,EAAA,QAAA,EAAA,QAAA,EAAA,EAAA,EAAA,IAAA,EAAA,oBAAoB,EAFpB,SAAA,EAAA,CAAC,EAAE,OAAO,EAAE,KAAK,EAAE,QAAQ,EAAE,SAAS,EAAE,CAAC;;2FAEzC,oBAAoB,EAAA,UAAA,EAAA,CAAA;kBAHhC,QAAQ;AAAC,YAAA,IAAA,EAAA,CAAA;AACR,oBAAA,SAAS,EAAE,CAAC,EAAE,OAAO,EAAE,KAAK,EAAE,QAAQ,EAAE,SAAS,EAAE,CAAC;iBACrD,CAAA;;;ACXD;;AAEG;;ACFH;;AAEG;;;;"}}}